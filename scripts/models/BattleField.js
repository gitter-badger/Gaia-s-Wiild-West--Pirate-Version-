/*global klass, Tile, Entity, EntityPool, Layer */

var BattleField = klass({

	tileSize: 0,
	scaledTileSize: 0,
	screenWidth: 0,
	screenHeight: 0,
	width: 10,					// amount of squares in X orientation
	height: 10,					// amout of squres in Y orientation
	maxSize: 22,				// max size for width and height
	minSize: 14,					// min size for width and height
	offsetX: 430,				// to store de original values of the first Tile 0,0
	offsetY: 150,				// to store de original values of the first Tile 0,0
	translatedX: 0,				// store the move on x-axis
	translatedY: 0,				// store the move on y-axis
	dx: 430,					// translation x to start a draw the map 
	dy: 38,						// translation y to start a draw the map 
	totalPlayableTiles: 0,
	serverMap: false,			// check if the map was generated by the server
	map: [],
	_forceRender: true,

	context: null,
	resources: null,

	_tilehovered: {
		x: null,
		y: null,
		oldX: 0,
		oldY: 0
	},

	frameCount: 0,

	subsoilLayer: "",
	terrainLayer: "",
	gridLayer: "",
	navLayer: "",  // layer that response to the mouse events

	objectsPool: "",

	initialize: function (configs) {
		if (configs) {
			Object.extend(this, configs);
		}

		this.objectsPool = new EntityPool();

		this.subsoilLayer = new Layer({zIndex: 1});
		this.terrainLayer = new Layer({zIndex: 2});
		this.gridLayer = new Layer({zIndex: 3});
		this.navLayer = new Layer({zIndex: 4});

		this.generateArena();
	},

	getServerMap: function (map) {
		if (map !== undefined) {
			this.map = map;
			this.serverMap = true;
		} else {
			throw false;
			// eh necessario garantir que o map sempre vira do server.
			// se algo der errado, outra requisicao devera ser feita.
			// implementar essa parada
		}
	},

	generateArena: function () {

		var mapSize = this.width * this.height,
			minPlayableTiles = 60,
			i = true;

		minPlayableTiles = Math.floor(minPlayableTiles * mapSize / 100);

		this.dx += this.translatedX;
		this.dy += this.translatedY;

		while (i) {
			this.createMapDimensions();
			this.totalPlayableTiles = this.generatePlayableArena();

			if (this.totalPlayableTiles > minPlayableTiles) {
				i = false;
			}
		}

		this.subsoilLayer.translate(this.dx, this.dy);
		this.subsoilLayer.isometricMode();

		this.gridLayer.translate(this.dx, this.dy);
		this.gridLayer.isometricMode();

		this.navLayer.translate(this.dx, this.dy);
		this.navLayer.isometricMode();

		this.setNonWalkableTiles();
	},

	createMapDimensions: function () {

		var maxSize = this.maxSize, // map max size
			minSize = this.minSize, // map min size
			terrain = this.resources.terrainElems,
			terrainLength = this.resources.resourcesType.terrain.length,
			terrainType,
			y,
			x;

		this.width = Math.floor(Math.random() * (maxSize - minSize + 1) + minSize);
		this.height = Math.floor(Math.random() * (maxSize - minSize + 1) + minSize);

		this.map = new Array(this.height);

		for (y = this.height - 1; y >= 0; y--) {
			this.map[y] = new Array(this.height);
			for (x = this.width - 1; x >= 0; x--) {
				terrainType = Math.floor(Math.random() * terrainLength);
				this.map[y][x] = new Tile({
					x: x,
					y: y,
					type: 0,
					terrain: terrainType,
					scaledTileSize: this.scaledTileSize
				});
			}
		}

		this.offsetX = (this.screenWidth / 2) + (this.height - this.width) *  (this.scaledTileSize / 2);
		this.offsetY = (this.screenHeight / 2) - ((this.scaledTileSize / 2 * this.height) + (this.width - this.height) * this.scaledTileSize / 4);

		this.dx = this.offsetX + this.translatedX;
		this.dy = this.offsetY + this.translatedY;
	},

	/**
	 * Defines tiles that can be walkable for characters.
	 * @return {integer} total of walkable tiles.
	 */
	generatePlayableArena: function () {

		var centerX = Math.floor((this.width - 1) / 2), // getting the central point in the arena
			centerY = Math.floor((this.height - 1) / 2),
			TotalTiles = this.width * this.height,
			ArenaPerCent = Math.floor(80 * TotalTiles / 100),
			tilePos,
			totalNeighborTiles,
			maxLoop = 0,
			tiles = 9,
			i,
			j;

		// setting a starting point in the map to create a route of common terrain to escape.
		for (i = 2; i >= 0; i--) {
			for (j = 2; j >= 0; j--) {
				this.map[centerY + (i - 1)][centerX + (j - 1)].type = 1; // verificar se existe essa posicao
				ArenaPerCent--;
			}
		}

		i = ArenaPerCent;

		while (i && tiles <= ArenaPerCent) {

			tilePos = this.getARandomMapPosition();

			totalNeighborTiles = this.findTotalWalkableNeighbors(tilePos.x, tilePos.y);
			if (totalNeighborTiles === 3) {
				tiles++;
				i--;
				maxLoop = 0;
				this.map[tilePos.y][tilePos.x].type = 1;
			} else {
				maxLoop++;
			}

			if (maxLoop > 100) {
				i = 0;
			}
		}

		return tiles;
	},

	/**
	 * Returns a position that has three neighbor tiles with type = 1
	 */
	findTotalWalkableNeighbors: function (x, y) {
		var neighborAmount = 0,
			map = this.map,
			i,
			j;

		for (i = 2; i >= 0; i--) {
			for (j = 2; j >= 0; j--) {
				if (map[y + (i - 1)] &&
				    map[y + (i - 1)][x + (j - 1)] &&
				    map[y + (i - 1)][x + (j - 1)].type === 1) {
					neighborAmount++;
				}
			}
		}

		return neighborAmount;
	},


	/**
	 * Returns a random x and y position of the battlefield.
	 * @return {object} 
	 */
	getARandomMapPosition: function () {

		var x,
			y,
			i = true,
			continueSearching = true,
			width = this.width,
			height = this.height;


		while (i) {
			x = Math.round(Math.random() * width);
			y = Math.round(Math.random() * height);

			x = x > (width - 1) ? x - 1 : x;
			y = y > (height - 1) ? y - 1 : y;


			if (this.map[y][x].type === 0 || this.map[y][x].type === null) {
				return {
					x: x,
					y: y
				};
			}
		}
	},

	/**
	 * Sets tiles that characters cannot walk.
	 * This tiles can be used to place Resources.
	 */
	setNonWalkableTiles: function () {
		var i,
			pos,
			index,
			objectIndex,
			totalResources = this.resources.totalResources,
			nonWalkable = this.resources.resourcesType.nonWalkable,
			resources = this.resources.elems,
			amount = this.resources.resourcesType.amount;

		for (i =  amount - 1; i >= 0; i--) {

			index = Math.floor(Math.random() * totalResources);
			pos = this.getARandomMapPosition();

			objectIndex = this.objectsPool.getEntity();
			this.objectsPool._entityPool[objectIndex].setImage(resources[nonWalkable[index]]);
			this.objectsPool._entityPool[objectIndex].setCoordinates(pos.x, pos.y);
			this.objectsPool._entityPool[objectIndex].calculate(this.dx, this.dy, this.scaledTileSize);
			this.map[pos.y][pos.x].type = 5; // that is right!

		}

		this.setSpecialWalkableTiles();
	},

	/**
	 * Sets tiles that characters walk affected by some type of effect.
	 * This tiles can be used to place that can coxists with characters.
	 */
	setSpecialWalkableTiles: function () {
		var map = this.map,
			width = this.width,
			height = this.height,
			x,
			y;

		for (y = height - 1; y >= 0; y--) {
			for (x = width - 1; x >= 0; x--) {
				if (map[y][x].type === 0) {
					map[y][x].type = 6;
				}
			}
		}
	},


	/**
	 * Place the resources images into the battleField
	 * @return {void}
	 */
	renderStaticObjects: function () {
		var i,
			amount = this.resources.resourcesType.amount;

		for (i = 0; i < amount; i++) {
			this.objectsPool._entityPool[i].forceRender();
		}
	},


	renderTerrain: function () {

		var context = this.terrainLayer.context,
			terrainNames = this.resources.resourcesType.terrain,
			terrains = this.resources.terrainElems,
			width = this.width,
			height = this.height,
			map = this.map,
			tile,
			image,
			pos,
			x,
			y;

		for (y = 0; y < height; y++) {
			for (x = 0; x < width; x++) {
				tile = map[y][x];
				pos = tile.findTileCenter(this.dx, this.dy);
				image = terrains[terrainNames[tile.terrain]];
				context.drawImage(image,  pos.x - (image.width / 2),  pos.y - (image.height) + 32);
			}
		}
	},

	/**
	 * Creates a subsoil bounds
	 * @return void
	 */
	renderSubsoil: function () {

		var context = this.subsoilLayer.context;
		var i;
		var x = this.tileSize * this.width;
		var y = this.tileSize * this.height;
		var h = this.tileSize;
		var halfH = h / 2;

		context.lineWidth = 1;
		context.fillStyle = '#986532';

		for (i = 0; i < this.width; i++) {
			context.moveTo(x - (i * h), y);
			context.lineTo(x  - ((i - 1) * h / 2) - (i * halfH), y  + halfH);
			context.lineTo(x - (i * halfH) - ((i + 1) * halfH), y  + halfH);
			context.lineTo(x  - ((i + 1) * h), y);
			context.lineTo(x  - (i * h), y);
		}

		for (i = 0; i < this.height; i++) {
			context.moveTo(x, y - (i * h));
			context.lineTo(x + h / 2, y - ((i - 1) * h + halfH));
			context.lineTo(x + h - halfH, y - (i * h) - halfH);
			context.lineTo(x, y - ((i + 1) * h));
			context.lineTo(x, y - (i * h));
		}

		context.fill();
		context.stroke();
	},


	/**
	 * Render all terrain and non NCP's related objects of the map.
	 * @return void
	 */
	renderGrid: function () {
		var context = this.gridLayer.context,
			width = this.width,
			height = this.height,
			tileSize = this.tileSize,
			dx = 0,
			dy = 0,
			x = 0,
			y = 0,
			i = 0;


		context.strokeStyle = "#000";
		context.globalAlpha = 0.15;
		context.lineWidth = 3;

		for (y = 0; y < height; y++) {
			for (x = 0; x < width; x++) {

				context.strokeRect(dx, dy, tileSize, tileSize);

				dx += tileSize;
			}
			dx = 0;
			dy += tileSize;
		}
	},

	renderNavLayer: function () {
		var context = this.navLayer.context,
			width = this.width,
			height = this.height,
			tileSize = this.tileSize,
			tile = this._tilehovered;

		if (tile.x !== null) {
			context.clearRect(tile.oldX * tileSize, tile.oldY * tileSize, tileSize, tileSize);
			if (this.map[tile.y][tile.x].type === 5) {
				context.fillStyle = "transparent";
			} else {
				context.fillStyle = "rgba(0, 0, 255, 0.3)";
			}
			context.fillRect(tile.x * tileSize, tile.y * tileSize, tileSize, tileSize);
		} else if (tile.x === null && tile.oldX !== null) {
			// the last tile
			context.clearRect(tile.oldX * tileSize, tile.oldY * tileSize, tileSize, tileSize);
		}
	},

	render: function (frame) {
		this.frameCount = frame;

		if (this._forceRender) {
			this.renderTerrain();
			this.renderGrid();
			this.renderSubsoil();
			this.renderStaticObjects();
		}
		this.renderNavLayer(frame);
		this._forceRender = false;
	},

	setTileCursorHover: function (coord) {
		this._tilehovered.oldX = this._tilehovered.x;
		this._tilehovered.oldY = this._tilehovered.y;
		this._tilehovered.x = coord.x;
		this._tilehovered.y = coord.y;
	},

	/**
	 * Returns all coordinates of the map
	 * @return {[type]} [description]
	 */
	getAttributes: function () {

		return {
			offsetX: this.offsetX,
			offsetY: this.offsetY,
			width: this.width,
			height: this.height,
			dx: this.dx,
			dy: this.dy
		};
	},

});